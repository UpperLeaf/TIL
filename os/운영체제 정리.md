# Operating System



# 목차

- [운영체제란 무엇인가](#운영체제란-무엇인가)





# 운영체제란 무엇인가

가장 간단하게 말하자면, 운영체제라는 컴퓨터의 하드웨어를 관리하는 프로그램이다. 컴퓨터는 하드웨어만 있다고 동작하지 않는다. 하드웨어 위에서 소프트웨어가 동작하는데, 이때 소프트웨어들은 하드웨어의 자원들을 사용할 필요가 있다. 이때 운영체제가 필요하다. 운영체제는 소프트웨어에게 하드웨어의 자원들을 어떻게 분배할 것인가? 에 대한 프로그램이다.

**OS is a resource allocator** 즉, OS는 컴퓨터의 모든 자원을 관리하고, 자원을 효율적으로 공평하게 사용하기 위해 누구에게 자원을 할당할 것인지 결정하는 프로그램이다.

### Interrupt Driven

CPU와 I/O 장치들은 동시적으로 작동한다. 
 I/O장치들은 장치 컨트롤러 (Device Controller)라는것이 존재하고, 그 안에 Local Buffer가 존재한다. I/O란 Device와 Device Controller간의 데이터 전달이다. 
**Input이란** Device에서 Device Controller의 지역 버퍼로 데이터가 옮겨지는 과정이고, **Output이란** Device Controller에서 Device로 데이터가 옮겨지는 과정이다. 
이후 Device Controller에서 I/O작업이 끝나면 CPU에게 Interrupt를 발생시키고, 이 후에 CPU는 해당 Interrupt를 처리하기 위해 작동하게되는것이다. 
그렇기 때문에 CPU가 I/O작업을 위해 기다리는것은 매우 비효율적이다. 그래서 보통 CPU는 I/O작업이 필요하면 일을 맡기고 CPU는 다른 일을 수행하게된다.

일반적으로 인터럽트는 처리하기 위한 소프트웨어가 존재한다. 이를 **Interrupt Service Routine**이라고 하는데, 인터럽트가 발생하면 CPU는 인터럽트를 처리하기 위해 해당 루틴으로 JUMP해서 인터럽트를 처리한다. 

RAM에는 Interrupt Service Routine들의 주소를 저장해놓은 Vector가 존재한다. 이를 Interrupt Vector라고 한다.

Interrupt는 하드웨어에서만 발생하는게 아니다. 소프트웨어에서도 Interrupt를 발생시킬 수 있는데 이를 Trap 또는 Exception이라고 한다. 이는 Error또는 User의 Request를 통해 발생한다.

**운영체제는 Interrupt Driven으로 동작한다.**

### I/O Structure

Process에서 I/O가 필요할때, CPU는 I/O Request를 하고 무엇을 할것인가?

1. I/O가 끝날때까지 CPU를 Wait하고, I/O가 끝나면 재동작하는 방식
2. 아무일도 하지 않는 Loop를 만들어서 동작 (Busy Waiting)
3. I/O가 끝날때까지 다른 프로그램을 동작하고, I/O가 끝나면 프로그램 재시작

**I/O는 CPU에 비해 굉장히 느리다. 그렇기때문에 CPU가 Wait 하는방식은 굉장히 비효율적이기 때문에 1번, 2번 방식은 사용하지 않는다.** 

### Main Memory

Main Memory란 CPU가 직접 접근할 수 있는 큰 Storage 장치이다. 

- Random Access : 메모리에 어느 위치에 접근하든지간 접근속도는 동일하다.
- Volatile : 휘발성 저장 장치이다.

Main Memory는 Random Access Memory라고 해서 줄여서 RAM이라고 불린다.

### Secondary Memory

큰 용량을 제공하는 저장 장치로, 비 휘발성이고 용량이 크다. 예전에는 자기 디스크를 많이 이용했지만 요즘에는 SSD라는 전자식 드라이브를 이용하여, 속도면에서 많은 효율을 얻고 있다.

### Memory Hierarchy

저장장치는 계층화 되어있다. 

![Operating%20System%20c77ca02659ca4fe0b181cedf9ae51aa2/Untitled.png](../assets/os_memory_hierarchy.png)

일반적으로 저장장치는 크게 접근 속도, 용량, 휘발성 3가지 특성을 이용하여 분류할 수 있다. 메모리 계층구조 위에서 아래로 향할 수록 데이터에 대한 접근시간이 길어지지만, 용량은 커진다.
MainMemory까지는 Volatility를 가지며, 그 아래로는 None-Volatility이다.

Cache란 컴퓨터 시스템의 여러곳에서 사용되는 기술로, 자주 사용되거나 최근에 사용된 데이터를 복사하여 저장하고, 이 후에 더 빠른속도로 데이터에 접근할 수 있게 해주는 기술이다. 메모리 계층구조에서 Cache는 레지스터와 RAM사이에 존재한다.

### Direct Memory Access

I/O속도가 매우 빠른 장치의 경우 Interrupt가 빈번하게 발생한다. CPU는 Interrupt가 발생하면, Interrupt를 처리해야하므로, 빈번하게 발생하는 상황에 대해서 CPU는 자기가 할 일을 제대로 하지 못 할 수 있다. 그래서 나온것이 **DMA(Direct Memory Access)**이다. DMA는 Device들이 메모리에 직접 접근하여 읽거나 쓸 수 있도록 하는 기능을 의미하는데 여기서 중요한 것은 CPU가 이 과정에 개입하지 않는다는 것이다.

![Operating%20System%20c77ca02659ca4fe0b181cedf9ae51aa2/Untitled%201.png](../assets/os_dma.png)

DMA를 이용해서, CPU가 해야할 일을 대신 처리하게 되면서, CPU의 효율을 늘리고 DMA는 데이터의 전송이 종료되었을때 1 Block 데이터의 단위로 CPU에게 Interrupt를 걸게 된다. 이는 결과적으로 CPU가 받는 Interrupt의 횟수를 줄이게 된다.

### MultiProcessing System

멀티 프로세싱 시스템은 여러개의 프로세서가 버스 때때로는 클락, 메모리를 공유하는 시스템이다. 이러한 시스템의 장점은 다음과같다.

- 처리량이 향상된다.

    프로세서의 수가 많아짐으로써, 적은 시간내에 더 많은 일을 처리할 수 있게된다. 하지만 프로세서가 N배 된다고해서 처리량이 N배가 되는것은 아니다. 다수의 프로세서가 협력하면서 생기는 오버헤드가 존재하기 때문이다.

- 경제적이다

    멀티 프로세싱 시스템은 다수의 싱글 프로세싱 시스템보다 경제적이다. 

- 안정성이 높아진다.

    몇개의 프로세서가 분산되어 일을 처리하기 때문에 한개의 프로세서가 고장나도, 전체 시스템이 중단되지는 않는다. 단지 느려질뿐이다. 

멀티 프로세싱 시스템은 2가지 타입이 존재한다.

- Asymmetric Multiprocessing (비대칭 멀티 프로세싱)

    각 프로세서가 특정한 일만 처리한다. 예를들면 Boss 프로세서는 시스템과 관련된 일을 처리하고, 다른 프로세서들은 미리 정의된 일만 처리하는 방식이다.

- Symmetric Multiprocssing (대칭 멀티프로세싱)

    일의 구분없이 프로세서들이 일을 처리한다. 

![Operating%20System%20c77ca02659ca4fe0b181cedf9ae51aa2/Untitled%202.png](../assets/os_multiprocessing_system.png)

## 운영체제가 하는 역할

### Job Scheduling

MultiProgramming 이란 메인 메모리에 여러 작업을 두고 I/O가 일어날때마다 다른 작업을 실행하는 방식이다. CPU는 동시에 한개의 작업만 실행할 수 있기 때문에 한 작업만 계속 실행해서는 안된다. 그렇기 때문에 I/O가 발생할때마다 다른 작업을 선택하는데 이는 운영체제가 Job Scheduling을 통해 선택하게 된다.

### Dual Mode

운영체제는 Mode Bit을 통해 OS를 다른 시스템으로부터 보호한다. User Mode와 Kernal Mode가 존재하며, Mode bit을 이용하면 시스템이 현재 User Code를 실행하는지, Kernal Code를 실행하는지 알 수 있다. 또한 몇가지 명령같은 경우 Kernal Mode의 권한으로만 실행할 수 있는 경우도 존재한다. System Call이 그러한데, System Call 을 하기 위해서는 Mode bit를 커널로 해야하고, 이후에 종료되면 다시 User모드로 되돌린다.

![Operating%20System%20c77ca02659ca4fe0b181cedf9ae51aa2/Untitled%203.png](../assets/os_dualmode.png)

### Process Management

프로세스란 프로그램이 실행중인 상태이다. 프로그램은 정적인 객체이며, 프로세스는 동적인 객체라고 생각할 수 있다. 프로세스는 자신의 일을 수행하기 위해 운영체제로부터 CPU와 메모리등을 할당받아서 자신의 일을 처리한다. Single Thread 프로세스 같은 경우 한가지의 Program Counter라는게 존재하는데 이것은 다음번에 실행할 명령어의 주소를 가르킨다. 만약 Multi Thread 프로세스라면 Thread 당 Program Counter가 생기게된다.

운영체제는 프로세스 생명주기를 관리한다. 시스템 프로세스를 생성하고 죽이거나, 중지하거나 재개한다. 또한 프로세스에게 동기화, 통신, DeadLock Handling 매커니즘을 제공하기도 한다.

### Memory Management

프로그램이 실행되기 위해서는 모든 명령 또는 데이터는 Main Memory에 존재해야한다. 운영체제는 어떤 프로세스가 어떤 메모리를 사용하는지 추적하고 프로세스가 필요한 만큼 메모리의 할당, 해제를 담당한다.

### File System Management

운영체제는 파일 시스템을 관리한다. 파일이나 폴더를 만들거나 삭제할 수 있으며, 파일에 대해 읽고 쓰는 기본적인 연산을 지원한다. 또한 파일을 백업할 수 있어야한다.

### Disk Management

운영체제는 디스크 공간을 할당하고, 디스크 읽기, 쓰기 요청을 스케줄링한다. 또한 캐시와 관련된 문제에서 HardDisk, RAM, Cache의 서로 같은 정보의 내용이 다르게 존재한다면 누가 최신의 정보인가를 처리해야한다. 이것을 Cache Coherence라고 한다.



# Process

프로세스란 동적으로 실행되는 프로그램을 의미한다. 

프로세스는 크게 Stack 영역, Heap 영역, Data 영역, Text영역으로 분리된다.

**Text영역은** 프로세스가 실행할 코드가 기계어 형태로 저장된 공간이다. 운영체제가 Text 영역을 보호하기 때문에 수정할 수 없다.

Self Modifing Code와 같은 기법은 런타임에 Text 영역에 기계어 코드를 직접적으로 작성하여, 프로그램의 실행명령을 바꾼다. 운영체제에 메모리에 대한 READ, WRITE, EXECUTE 권한을 **mprotect()**라는 System Call을 요청하여 얻을 수 있다.

**Data영역은** 코드에서 선언한 전역변수, Static 변수 등등이 저장된 공간이다.

![Operating%20System%20c77ca02659ca4fe0b181cedf9ae51aa2/Untitled%204.png](../assets/os_process_memory.png)

프로세스에서 **Stack 영역은** 일반적으로 위에서 아래로 할당된다. 보통 프로그램은 컴파일 타임에 선언된 변수를 확인하여, Stack의 크기를 결정한다. 

보통 Procedure를 실행하게 되면 한개의 **Activation Record**가 생기는데 이는 프로시저가 호출되면 Stack 영역에 한개씩 쌓이게 되고, Procedure가 종료되면 사라지게 된다. Activation Record는 프로시저의 실행에 필요한 데이터들을 관리한다.

Heap영역은 프로세스에서 필요할때마다 동적으로 할당받을 수 있는 메모리 영역이다. 즉 Heap의 사용량은 Runtime에 결정된다. 일반적으로 malloc()과 같은 System Call을 이용하면 Heap 영역의 메모리를 얻어서 사용할 수 있다. Heap 영역은 할당받고 사용을 완료했으면 반드시 메모리를 해제해야한다. 그렇지않으면 **Memory Leak (메모리 누수)**가 발생한다.

### Life Cycle

프로세스는 살아생전 총 5개의 상태를 가지게 된다.

![Operating%20System%20c77ca02659ca4fe0b181cedf9ae51aa2/Untitled%205.png](../assets/os_process_lifecycle.png)

- new : 프로세스가 처음 만들어진 상태
- ready : cpu를 운영체제로부터 할당받기전 대기중인 상태
- running : 명령이 실행중인 상태
- waiting : 어떤 사건 or I/O를 기다리고 있는 상태
- terminated : 프로세스가 종료된 상태

### Process Control Block

프로세스 제어 블록 일명 PCB는 프로세스의 관련 정보를 저장하는 구조체이다. 

일반적으로 Process의 Context Switching이 일어나면, 실행중인 프로세스 정보를 PCB에 기록하고, 기다리고 있던 다른 프로세스의 PCB를 읽어 해당 프로세스를 실행한다.

![Operating%20System%20c77ca02659ca4fe0b181cedf9ae51aa2/Untitled%206.png](../assets/os_process_pcb.png)

## Process Scheduling

CPU는 한정적인 하드웨어 자원이고, 운영체제는 어떤 프로세스에게 CPU를 할당할 것인지, 선택해야한다. 

일반적으로 스케줄링을 하기 위해서 여러개의 큐가 존재한다.

- Job Queue : Disk에서 Ready 상태로 가기전 프로세스들이 존재하는 Queue이다.
- Ready Queue : Memory에서 CPU를 받기 위해 기다리는 프로세스들이 존재하는 Queue이다.
- Device Queue : Device Controller에 존재하는 Queue이다. 프로세스들이 I/O장치를 이용하기 위해 대기한다.

### Long Term Scheduling

JobQueue에서 Ready Queue로 Job을 가져오는 Schduler이다. 이름 그대로 긴 주기를 가지고 한번씩 실행되며, 메모리에 있는 작업의 개수를 조절한다. 

### Short Term Scheduling

Ready중인 프로세스에게 CPU를 할당하는 스케줄러이다. 자주실행되며 매우 빨라야 한다.

### Type of Process

프로세스는 주로 작업하는 종류에 따라 2가지로 분류된다.

- I/O Bound Process : I/O 중심의 프로세스
- CPU Bound Process : CPU 중심의 프로세스

좋은 시스템 성능을 위해서는 I/O 중심의 프로세스와 CPU 중심의 프로세스를 Long - Term Scheduler가 적절히 선택해야 한다.

### Medium Term Scheduler

여러명의 사용자가 여러 프로세스를 실행시켜서 메인 메모리가 부족해진다면, 작업중인 일부의 프로세스를 디스크로 내려보내고 여유가 생기면 다시 올려서 실행한다. 이를 **Swapping**이라고 한다.

### Process의 생성과 종료

프로세스간 부모 자식 관계를 선으로 표시하면 Tree가 만들어 진다.

프로세스를 생성할때 Resource Sharing Option을 선택할 수 있다.

1. 모든 자원을 공유한다.
2. 일부 자원만 공유한다.
3. 공유하지 않는다.

또한 실행 Option을 선택할 수 있다.

1. 부모 자식 프로세스를 동시에 실행한다.
2. 자식 프로세스가 종료할때까지 부모 프로세스가 대기한다.

![Operating%20System%20c77ca02659ca4fe0b181cedf9ae51aa2/Untitled%207.png](../assets/os_process_hierachy.png)

보통 프로세스는 Fork() 시스템 콜로 탄생하여, Exit() 이라는 시스템콜로 종료된다. 하지만 부모 프로세스가 abort() 시스템 콜을 이용하여 강제 종료 시킬 수 있다.

일반적으로 자식 프로세스는 부모 프로세스가 없으면 실행이 되지 않는다. 이때 2가지 전략이 존재한다.

1. 부모가 사라지면 모든 자식프로세스가 종료된다. (CasCade Termination)
2. 다른 프로세스의 양자로 들어간다.

만약 부모가 자식 프로세스의 종료를 기다리지 않고 있으면 PCB를 반납할 수 없다. 이는 좀비 프로세스를 생성하게 된다. 또한 이러한 상황에서 부모 프로세스가 종료된다면, 이때 자식 프로세스를 고아 프로세스라고 한다.

### Interprocesses Communication (프로세스간 통신)

우리는 실제로 프로그램을 동작시킬때 한개의 프로세스만 수행되지 않는 경우도 존재한다. 상황에 따라서 여러개의 프로세스가 협력해야하는 케이스가 많이 존재하며, 이때 협력하기 위해서 프로세스간 통신하는 방법이 필요하다. 보통 2가지 방법이 존재한다.

1. **Shared Memory**
   보통 Shared Memory는 공유메모리를 의미한다. Process끼리 공유하는 메모리가 존재하고, 이에 대해 접근할 수 있는것이다.
   보통 프로세스간 통신은 생산자와 소비자가 존재한다. 만약 Shared Memory가 무한하다면, 생산자는 Memory가 부족하다는것을 인지하지 못하고 계속해서 Message를 생산할 것이다. 하지만 Shared Memory는 유한하다. 그렇기 때문에 Producer - Consumer 문제가 발생한다.
   이러한 문제는 원형 Linked List를 이용하여 해결할 수 있다. 공유메모리에 접근할때 발생하는 동기화 문제는 프로세스끼리 알아서 잘해결해야한다. 즉 아래의 코드에서 in과 out은 상호배제이다. 

    ```java
    //Producer
    while(in + 1 == out) 
    	donothing //기다린다.
   
    //Consumer
    while(in == out)
    	donothing // 기다린다.
    ```

2. **Message Passing**
   프로세스간 동기화와 통신을 하기 위해서 사용한다. 

    - 직접 통신

      프로세스간 직접적으로 링크가 구성된다. 
      send(P, message) : P에게 메시지를 보낸다.
      receive(Q, message) : Q로부터 메시지를 받는다.

      ![Operating%20System%20c77ca02659ca4fe0b181cedf9ae51aa2/Untitled%208.png](../assets/os_message_passing_direct.png)

    - 간접 통신

      중간에 Mail Box를 두고 이곳에 메시지를 작성하고 읽어가는 방식으로 작동한다. Mail Box는 고유 Id가 존재한다. 이 방식은 여러개의 프로세스가 접근할 수 있고, Mail Box 자체를 여러개 생성하여 여러 링크를 구성할 수 있다.

      ![Operating%20System%20c77ca02659ca4fe0b181cedf9ae51aa2/Untitled%209.png](../assets/os_message_passing_indirect.png)

3. **PIPE**

   파이프 또한 IPC 방법 중 하나이다. 파이프는 프로세스간 데이터를 주고 받는 통로를 의미한다.

   - Ordinary Pipe (익명 파이프)

     부모-자식 관계에서 데이터를 일방적으로 전달한다.

   - Named Pipe(이름있는 파이프)

     부모관계가 아니여도 양방향으로 데이터를 교환할 수 있다.

4. **Socket**

   컴퓨터 간 통신을 할때 사용한다. Socket이란 IP와 Port를 합친것을 의미한다. 

5. **RPC (Remote Procedure Call) 프로세스간 추상화된 프로시저 콜**

   Data는 기계에 따라서 Big-Endian 또는 Littel-Endian으로 나타나기때문에 기계에 종속적이다. 이때 이 Data를 기계에 독립적으로 변환하는것을 Marshalling이라고 한다. 
   RPC의 사용자는 다른 컴퓨터의 위치와 포트번호를 이용하여, RPC 메세지를 작성하고 데이터를 전송한다 이후 메서드 실행결과를 상대측으로부터 전달받는다.