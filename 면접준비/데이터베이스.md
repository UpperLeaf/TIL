# 데이터베이스

Created: Mar 13, 2021 12:46 PM

# 인덱스란?

DBMS에서 인덱스를 말할때 항상 책의 찾아보기를 비유하곤 한다. 책에서 키워드에 해당하는 부분이 인덱스이고, 그에 해당하는 페이지 번호가 레코드의 주소, 그리고 책의 내용이 데이터 파일에 해당한다고 볼 수 있다.

인덱스의 또 다른 특성을 자료구조로써 설명하자면 ArrayList와 SortedList로 설명할 수 있다. 데이터 파일은 ArrayList처럼 저장된 순서대로 별도의 정렬없이 저장하며, 인덱스는 SortedList처럼 저장되는 값을 정렬하여 저장한다.

SortedList의 장점이라면 List가 정렬되어있기 때문에 굉장히 빠른속도로 데이터를 얻을 수 있다는 점이다. 

단점이라면 값을 삽입하고 삭제하고 변경하면 재정렬해야하므로 성능이 많이 느리다는 점이다.

**결론적으로 Index는 데이터의 저장 성능을 희생하고, 그 대신 데이터의 읽기 속도를 높이는 기능이다.**

데이터의 인덱스를 하나 더 추가하는것은 데이터의 저장속도를 어디까지 희생할 것인가? 와 읽기 속도를 얼마나 더 빠르게 만들어야하는지? 에대한 질문이라고 할 수 있다.

데이터 저장 방식(알고리즘)별로 분류하는것은 많은 분류가 존재하겠지만 대표적으로  B-Tree 인덱스와 Hash 인덱스가 존재한다.

# B-Tree 인덱스

B-Tree는 칼럼에 원래 값을 변형시키지 않고, 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다. 전문검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 이용할 정도로, 일반적인 상황에 적합하다.

![%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20f86f2faf5eaa45eeb6683dfdaab51d39/Untitled.png](../assets/db_btree.png)

B-Tree는 트리 구조의 최상위에 Root 노드가 존재하고 그 하위에 자식 노드들이 붙어있는 형태이다. 트리구조의 가장 하위에 있는 노드를 Leaf노드라 하고, 그 중간에 있는 모든 노드를 Branch 노드라고 한다. 

Leaf노드는 항상 실제 데이터 (레코드)를 찾아가기 위한 주소 값을 가지고 있다. 단 레코드의 주소는DBMS에 따라 물리적인 레코드 주소일 수 도 있고 내부적인 레코드 번호일 수 도 있으며 InnoDB 엔진 같은 경우 PK로 테이블을 클러스터링 하기 때문에 PK자체가 주소 역할을 할 수 있다.

### 인덱스 키 추가

새로운 인덱스 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키값이 인덱스에 저장된다. B-Tree에 저장될때는 저장될 키 값을 이용해서 적절한 위치를 선택해야한다. 저장될 위치가 선택되면 B-Tree의 리프노드에 저장한다. 만약 리프노드가 꽉차있다면 분리되야 하는데, 이는 상위 브랜치 노드까지 범위가 넓어지기 때문에 B-Tree는 쓰기작업이 비용이 많이 든다.

### 인덱스 키 삭제

삭제하고자 하는 리프노드를 찾아 삭제마크만 하면 작업이 완료된다. 이후 이 인덱스 공간은 방치되거나 재활용된다.

### 인덱스 키 변경

인덱스 키 값은 그 값에 따라 저장될 리프노드의 위치가 결정되므로, 키 값을 쉽게 변경할 수 없다. 그래서 인덱스의 키 삭제 후 키를 다시 추가한다.

### 인덱스 키 검색

인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐, 최종 리프 노드까지 이동하면서 비교작업을 수행한다. 이과정을 "트리 탐색"이라고 한다.

B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 일부분만 일치하는경우에만 사용할 수 있다. 부등호 연산 ("<>")은 사용불가능하다.

### 인덱스 레인지 스캔

인덱스 레인지 스캔은 인덱스 접근 방법 가운데 가장 대표적인 접근 방식으로, 레코드를 한건 또는 한건 이상을 읽는 경우를 표현한다. 인덱스 레인지스캔은 검색해야 할 인덱스의 범위가 결정되었을때 사용하는 방식이다

![%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20f86f2faf5eaa45eeb6683dfdaab51d39/Untitled%201.png](../assets/db_btree_index_range_scan.png)

### 인덱스 풀 스캔

인덱스 풀 스캔은 인덱스를 처음부터 끝까지 전부다 읽는 방식이다. 인덱스 풀 스캔은 인덱스의 내용으로만으로도 쿼리를 처리할 수 있을때 사용되며, I/O가 줄어들기 때문에 좀 더 효율적으로 쿼리를 처리할 수 있다. 다만 이런식으로 인덱스를 사용하는 것이 옳은 방식은 아니다.

# Hash 인덱스

해시 인덱스는 B-Tree만큼 범용적이지는 않지만, 고유의 특성과 용도를 지닌 인덱스 가운데 하나다.

해시 인덱스는 동등 비교 검색에는 최적화 되어있지만, 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다. 

일반적으로 Hash 인덱스는 메모리 기반의 테이블에 주로 구현돼있으며, 디스크 기반의 대용량 테이블용으로는 거의 사용되지 않는다.

해시 인덱스의 큰 장점은 실제 키 값과는 상관없이 인덱스의 크기가 작게 형성된다는 점이다. 
검색하고자 하는 값을 주면 해시함수를 거쳐서 찾고자 하는 키값이 포함된 버켓을 알아낼 수 있다. 그 버켓 하나만 읽어서 비교해보면 실제 레코드가 저장된 위치를 알 수 있다.

해시인덱스는 원래의 키값을 저장하는게 아니라, 해시함수의 결과를 저장하기 때문에 키 칼럼의 값이 상당히 줄어든다. 그래서 해시 인덱스는 B-Tree 인덱스보다는 상당히 크기가 작다.